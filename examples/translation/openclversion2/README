After a sudden realization, I find that I need almost none of the openCL stuff
The programs can be broken into these very simple parts:
1. Get the number of devices, give them ids
  Related to clGetDevices
2. Prepare to make threads threads using device ids as "ranks"
  based either on array index or their device id
  Give them variables from __global or __local, remember that local is default
  global means that each one gets from a pointer to the same variable
  Use the kernel text for the above
*
  
3. Get the paramater inputs from what would be from clSetKernelArg, possibly clEnqueueWriteBuffer
  
4. Spawn processes in the same order as clEnqueueNDRangeKernel
  Stick data in the arrays

5. Store output somewhere else
  May come from arrays 

6. Possibly free

Considerations:
  Make a struct for the array that holds:
  Rank
  Any variables that go in

Figure out something to do with local variables

How to make sure that none of the numbers are 

Should the user be expected to change variables that end up too big for civl?

Remove mentions of "unsigned" as they are not supported yet
Same for vector types

Basic idea of conversion program:
Kernel - After getting input on where the kernel is (or not):
  Get all of the parameters, they will become variables and part of a struct
  put all of the rest in, add device_id as a parameter, convert get_global_id(0) to something else


To simulate workgroups:
  Possibly have a function in between kernel and $spawn

Problems:
Sick
Spent lots of time to figure out odd behavior to realize that floats and random do not work as expected
