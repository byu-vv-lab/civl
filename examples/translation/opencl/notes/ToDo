use demoCL in Xcode to get hardware info (driver version openCL 1.1)

square.c


Types:
size_t
cl_device_id
cl_context
cl_command_queue
cl_program
cl_kernel

cl_mem
Types for now are just structs, see cl.h
------Above this line are implemented-------
Hardware methods:

methods are externs
  Declared but not defined unless given one

clGetDeviceIDs
  uses int err, takes 5 parameters
  http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetDeviceIDs.html
  [x]
  
  cl_int clGetPlatformIDs(	cl_uint num_entries,
 	cl_platform_id *platforms,
 	cl_uint *num_platforms)
 	
clCreateContext
  uses a cl_context context, takes 6 parameters
  http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateContext.html
  openCL uses them for commands, memory, program, kernel objects, executing kernels
  [x]

Kernels and other:
clCreateCommandQueue
  uses a cl_command_queue commands, takes 4 parameters
  uses &device_id and &err
  http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateCommandQueue.html
  [x]
  
clCreateProgramWithSource
  uses cl_program program, takes 5 parameters
  uses context
  -IN PROGRESS-
  
clCreateProgramWithBinary
  [x], see clCreateProgramWithSource
  
clBuildProgram
  [x]

//clGetProgramBuildInfo

clCreateKernel
[x]

clCreateBuffer
[]

[6/17/14, 2:29:20 PM] Manchun Zheng: you'll need to malloc it every time you increase the size
[6/17/14, 2:30:12 PM] Manchun Zheng: for example T* buffer = (T*) malloc(sizeof(T));
[6/17/14, 2:30:33 PM] Manchun Zheng: then when you want to add a new T to buffer
[6/17/14, 2:30:49 PM] Manchun Zheng: btw, you also need to keep track of the size of buffer.
[6/17/14, 2:30:55 PM] Manchun Zheng: so initially, size = 1;
[6/17/14, 2:31:00 PM] Manchun Zheng: when you add a new T
[6/17/14, 2:31:17 PM] Jean Jacques Rousseau: ah, got it
[6/17/14, 2:31:44 PM] Manchun Zheng: you malloc by (size+ 1)*sizeof(T)
[6/17/14, 2:31:52 PM] Manchun Zheng: and then you copy the previous data
[6/17/14, 2:31:55 PM] Manchun Zheng: and add the new data

clEnqueueWriteBuffer
[]

clSetKernelArg
[]

clGetKernelWorkGroupInfo
[]

clEnqueueReadBuffer
[]

clReleaseMemObject
[]

clReleaseProgram
[]

clReleaseKernel
[]

clReleaseCommandQueue
[]

clReleaseContext
[]

Kernel code changes
[6/17/14, 12:34:48 PM] Jean Jacques Rousseau: oh, right
[6/17/14, 12:35:48 PM] Jean Jacques Rousseau: although, I think I found it
[6/17/14, 12:36:04 PM] Jean Jacques Rousseau: this Comm is a struct, and one of the fields is storing the rank
[6/17/14, 12:36:12 PM] Jean Jacques Rousseau: when you make it, put in the rank yourself

flam naught shy stub
bash
Done: clGetDeviceIDs, clCreateKernel, clCreateBuffer

ToDo:

Problems:
Alterations to clGetDeviceIDs, slight problems with structs and pointers combined
Found a bug with size_t
Baffled by behavior that turned out to be caused by verify taking multiple paths

Possible simplified implementation?
Instead of buffers just turn them into straight variables
May lose some power, can't use sizeof(type) * number

CIVL code to consider:
$proc is like a processid, but not an int
$proc_null($proc *p);

$self, refers to self

$spawn f(expr,...,exprn);
or
$proc p = $spawn f(i);

$gbarrier or $barrier (one is global)