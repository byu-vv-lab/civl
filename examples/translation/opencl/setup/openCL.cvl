
#include "cl.cvl"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

$input int DEVICE_ID;
$input int DEVICE_ID_BOUND;

$assume 0 < DEVICE_ID && DEVICE_ID < DEVICE_ID_BOUND;


  

int clGetDeviceIDs(cl_platform_id platform, 
  cl_device_type device_type, 
  cl_uint num_entries, 
  cl_device_id *devices, 
  cl_uint *num_devices)
  {
  //$assume device_type == CL_DEVICE_TYPE_DEFAULT;
  int i = 0;
  //cl_platform_id int value can be null

  //num_entries number of devices that can be added
  /*
  if(num_entries == 0 && devices != 0)
  {
    return CL_INVALID_VALUE;
  }
 	
  if(num_entries == 0 && devices == 0)
  {
    return CL_INVALID_VALUE;
  }
 	*/
  //device_type type a bitfield that somehow gets type of OpenCL device
  //use the device types, look in openCLtypes and look for CL_DEVICE_TYPE_...

  /*
  if(device_type & (CL_DEVICE_TYPE_DEFAULT | CL_DEVICE_TYPE_CPU | 
    CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_ACCELERATOR | 
    CL_DEVICE_TYPE_CUSTOM | CL_DEVICE_TYPE_ALL))
  {
  */
    while (i < num_entries)
    {
      if(devices)
      {
        devices[0] = (cl_device_id)(&DEVICE_ID);
        //how to say "use anything"?
        i++;
      }
      else
      {
        break;
      }
      
    }
    if (num_devices)
    {
      *num_devices = i;
    }
  //}
/*
  else
  {
    return CL_DEVICE_NOT_FOUND;
  }
*/
  //*devices list of devices found, use
  //cl_device_id device_id;
  //&device_id
 	
  return CL_SUCCESS;

}




cl_context clCreateContext(const cl_context_properties  *properties,
                 cl_uint                       num_devices,
                 const cl_device_id *          devices,
                 void (CL_CALLBACK *pfn_notify)(const char *, const void *, size_t, void *),
                 void *                        user_data,
                 cl_int *                      errcode_ret)
{
  cl_int default_errcode_ret;
  cl_context ctx;
  
  if(!errcode_ret)
  {
    errcode_ret = &default_errcode_ret;
  }
    
  if (!devices || !num_devices || (!pfn_notify && user_data))
  {
    *errcode_ret = CL_INVALID_VALUE;
    return 0;
  }
    
  *errcode_ret = CL_SUCCESS;
  
  ctx = (cl_context)malloc(sizeof(_cl_context));

  
  ctx->properties = properties;
  ctx->num_devices = num_devices;
  ctx->devices = devices;
  ctx->pfn_notify = pfn_notify;
  ctx->user_data = user_data;
  ctx->errcode_ret = errcode_ret;
  
    
  if(*errcode_ret != CL_SUCCESS)
  {
    //delete ctx;
    return 0;
  }
  
  return(cl_context) ctx;
   
}

cl_command_queue clCreateCommandQueue(cl_context context,
  cl_device_id device,
  cl_command_queue_properties properties,
  cl_int* errcode_ret)
{
  cl_int default_errcode_ret;
  cl_command_queue cmd;
  
     // No errcode_ret ?
  if (!errcode_ret)
  {
    errcode_ret = &default_errcode_ret;
  }
  
  cmd = (cl_command_queue)malloc(sizeof(_cl_command_queue));
  
  cmd->context = context;
  cmd->device = device;
  cmd->properties = properties;
  cmd->errcode_ret = errcode_ret;
  
  return cmd;
  
  
}

cl_program clCreateProgramWithSource(cl_context context,
  cl_uint count,
  const char** strings,
  const size_t * lengths,
  cl_int * errcode_ret)
{
  cl_int default_errcode_ret;
  
  if(!errcode_ret)
  {
    errcode_ret = &default_errcode_ret;
  }
  
  *errcode_ret = CL_SUCCESS;
  //*errcode_ret = loadSources(count, strings, lengths);
  
  //corrects 
  for (cl_uint i = 0; i < count; i++)
  {
    size_t len = 0;
    const char *data = strings[i];
    
    if (lengths && lengths[i])
    {
      len = lengths[i];
    }
    else
    {
      len = strlen(data);
    }
    
    //remove trailing \0's, or null characters
    while (len > 0 && data[len-1] == 0)
    {
      len--;
    }
    //merge strings? The assignment isn't used anywhere
    //consider it later, if needed
    
  }
  $assert (*errcode_ret != CL_SUCCESS);
  //the original for loop can make *errcode_ret not CL_SUCCESS, this is a placeholder
  
  return (cl_program) program;
}


