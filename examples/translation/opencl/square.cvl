#include <civlc.h>
#include <stdio.h>
#include "setup/openCL.cvl"

$input int DATA_SIZE;

//this is the kernel that gets loaded into the program
// Simple compute kernel which computes the square of an input array 
//CIVL can't turn a string into a function at this time

//const char *KernelSource = "__kernel void square(   __global float* input,   __global float* output,   const unsigned int count){   int i = get_global_id(0);   if(i < count)       output[i] = input[i] * input[i];}";

// Simple compute kernel which computes the square of an input array 
//
const char *KernelSource = "\n" \
"__kernel void square(                                                       \n" \
"   __global float* input,                                              \n" \
"   __global float* output,                                             \n" \
"   const unsigned int count)                                           \n" \
"{                                                                      \n" \
"   int i = get_global_id(0);                                           \n" \
"   if(i < count)                                                       \n" \
"       output[i] = input[i] * input[i];                                \n" \
"}                                                                      \n" \
"\n";
/*
void square(float* input, float* output, const unsigned int count)
{
  int i = get_global_id(0);
  if (i < count)
  {
    output[i] = input[i] * input[i];
  }
}
*/
void main()
{
  int err;
  int num_entries = 1;
  
  cl_device_id device_id;
  cl_context context;
  cl_command_queue commands; 
  cl_program program;
  cl_kernel kernel;
  
  cl_mem input;
  cl_mem output;
  
  float data[DATA_SIZE];
  float results[DATA_SIZE];
  unsigned int correct;        
  
  int i = 0;
  int count = DATA_SIZE;
  for(i = 0; i < count; i++)
  {
    data[i] = rand() / (float)RAND_MAX;
  }
  
  //assumes you have hardware that works, does not check that part
  //fills the device_id with device ids, returns CL_SUCCESS if it works
  
  err = clGetDeviceIDs(NULL,
  CL_DEVICE_TYPE_GPU,
  num_entries,
  &device_id,
  NULL);
  //for non arrays, print using device_id[0], otherwise use *device_id[0];
  printf("devices is %d", device_id[0]);
  $assert (err == CL_SUCCESS);
  
  //if not using an array, use &device_id
  //Returns a context, which has device information
  context = clCreateContext(0, 1, &device_id, NULL, NULL, &err);
  $assert (context != NULL);
  
  commands = clCreateCommandQueue(context, device_id, 0, &err);
  $assert (commands != NULL);
  //if not using an array, use device_id, no []
  program = clCreateProgramWithSource(context, 1, (const char **) & KernelSource, NULL, &err);
  $assert (program != NULL);
  
  err = clBuildProgram(program, 0, NULL, NULL, NULL, NULL);
  $assert (err == CL_SUCCESS);
  
  kernel = clCreateKernel(program, "square", &err);
  $assert (kernel != NULL || err == CL_SUCCESS);
  //is sizeof(int), was float before bug
  input = clCreateBuffer(context,  CL_MEM_READ_ONLY,  sizeof(int) * count, NULL, NULL);
  output = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(int) * count, NULL, NULL);
  $assert (input || output);
  //printf("\nsizeof of input is %zu ", (size_t)sizeof(input));
  //a reminder that c can't get sizeof a pointer pointing to something else so easily
  
}
