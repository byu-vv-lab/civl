#ifdef __CIVL_CIVLMPI__
#else
#define __CIVL_CIVLMPI__

#include <civlc.cvh>
#include <concurrency.cvh>
#include <comm.cvh>
#include <bundle.cvh>
#include <mpi.h>
#include <civl-mpi.cvh>
#include <string.h>
#include <pointer.cvh>

/**************************** Duplicated Part *************************************/
/* Duplicated definition with the same struct in mpi.h.
   The reason of this duplication is to make civlmpi.cvl
   independent with mpi.cvl. */
typedef struct MPI_Comm {
  $comm p2p; // point-to-point communication
  $comm col; // collective communication
  $barrier barrier;
}MPI_Comm;

/* Definition of CMPI_Gcomm (CMPI_Gcomm has a type of __CMPI_Gcomm) 
   and MPI_Comm */
struct CMPI_Gcomm {
  $gcomm p2p; // point-to-point communication
  $gcomm col; // collective communication
  $gbarrier gbarrier;
};

/****************************** Helper Functions **********************************/
int sizeofDatatype(MPI_Datatype datatype) {
  switch (datatype) {
  case MPI_INT:
    return sizeof(int);
  case MPI_2INT:
    return (sizeof(int)*2);
  case MPI_FLOAT:
    return sizeof(float);
  case MPI_DOUBLE:
    return sizeof(double);
  case MPI_CHAR:
    return sizeof(char);
  case MPI_BYTE:
    return sizeof(char); // char is always one byte ?
  case MPI_SHORT:
    return sizeof(short);
  case MPI_LONG:
    return sizeof(long);
  case MPI_LONG_DOUBLE:
    return sizeof(long double);
  case MPI_LONG_LONG_INT:
    return sizeof(long long int);
  case MPI_LONG_LONG:
    return sizeof(long long);
  case MPI_UNSIGNED_LONG_LONG:
    return sizeof(unsigned long long);
  default:
    $assert(0, "Unreachable");
  }
}

/************************** MPI LIB Implementations *******************************/
CMPI_Gcomm CMPI_Gcomm_create($scope scope, int size) {
  CMPI_Gcomm result;

  result.p2p = $gcomm_create(scope, size);
  result.col = $gcomm_create(scope, size);
  result.gbarrier = $gbarrier_create(scope, size);
  return result;
}

void CMPI_Gcomm_destroy(CMPI_Gcomm gc) {
  $gcomm_destroy(gc.p2p);
  $gcomm_destroy(gc.col);
  $gbarrier_destroy(gc.gbarrier);
}

MPI_Comm CMPI_Comm_create($scope scope, CMPI_Gcomm gc, int rank) {
  MPI_Comm result;
  
  result.p2p = $comm_create(scope, gc.p2p, rank);
  result.col = $comm_create(scope, gc.col, rank);
  result.barrier = $barrier_create(scope, gc.gbarrier, rank);
  return result;
}

void CMPI_Comm_destroy(MPI_Comm comm) {
  $comm_destroy(comm.p2p);
  $comm_destroy(comm.col);
  $barrier_destroy(comm.barrier);
}

int _MPI_Init(void) {
  CMPI_Set_status(__INIT);
  return 0;
}

int _MPI_Finalize(void) {
  CMPI_Set_status(__FINALIZED);
  return 0;
}

void * CMPI_PointerAdd(const void * ptr, int offset, MPI_Datatype datatype) {
  int type_size = sizeofDatatype(datatype);

  return $pointer_add(ptr, offset, type_size);
}

/********************* Note *********************/
/* CMPI_Send and CMPI_Recv are a pair of send receives functions that
   help implementing MPI routines. They should never be block which
   means no potential deadlocks related to these functions */
int CMPI_Send(void *buf, int count, MPI_Datatype datatype, int dest,
	      int tag, $comm comm) {
  if (dest >= 0) {
    int size = count*sizeofDatatype(datatype);
    int place = $comm_place(comm);
    $message out = $message_pack(place, dest, tag, buf, size);
    $comm_enqueue(comm, out);
  }
  return 0;
}

int CMPI_Recv(void *buf, int count, MPI_Datatype datatype, int source,
	      int tag, $comm comm, MPI_Status *status) {
  if (source >= 0 || source == MPI_ANY_SOURCE) {
    $message in = $comm_dequeue(comm, source, tag);
    int size = count*sizeofDatatype(datatype);

    $message_unpack(in, buf, size);
    if (status != MPI_STATUS_IGNORE) {
      status->size = $message_size(in);
      status->MPI_SOURCE = $message_source(in);
      status->MPI_TAG = $message_tag(in);
      status->MPI_ERROR = 0;
    }
  }
  return 0;
}

/********************* Collective helper functions ********************/
/* Note: collective helpers functions are functions have same
   behaviors as MPI collective functions, it can be re-used as a part
   of implementation by different MPI routines. For example,
   MPI_Allreduce will call CMPI_Reduce and CMPI_Bcast, both of them
   should throw errors (if encounters any) as if errors are thrown
   from MPI_Allreduce.
*/
int CMPI_Collective_recv(void *buf, int count, MPI_Datatype datatype, 
			 int source, int tag, $comm comm, 
			 MPI_Status * status, char * routName) {
  if(source >= 0 || source == MPI_ANY_SOURCE) {
    $message in = $comm_dequeue(comm, source, MPI_ANY_TAG);
    int size = count*sizeofDatatype(datatype);
    int recvTag;

    recvTag = $message_tag(in);
    $assert (recvTag == tag , "Collective routine %s receives a "
	     "message with a mismatched tag\n", routName);
    $message_unpack(in, buf, size);
    if (status != MPI_STATUS_IGNORE) {
      status->size = $message_size(in);
      status->MPI_SOURCE = $message_source(in);
      status->MPI_TAG = recvTag;
      status->MPI_ERROR = 0;
    }
  }
  return 0;
}

/* Broadcast helper function that uses any specified message tag */
int CMPI_Bcast(void *buf, int count, MPI_Datatype datatype, int root, int tag,
	       MPI_Comm comm, char * routName) {
  if ($comm_place(comm.col) == root) {
    int nprocs = $comm_size(comm.col);

    for (int i=0; i<nprocs; i++)
      if (i != root)
	CMPI_Send(buf, count, datatype, i, tag, comm.col);
  } else
    CMPI_Collective_recv(buf, count, datatype, root, tag, comm.col,
			 MPI_STATUS_IGNORE, routName);
  return 0;
}

/* Reduction helper function that uses any specified message tag */
int CMPI_Reduce(const void* sendbuf, void* recvbuf, int count,
		MPI_Datatype datatype, MPI_Op op, int root, int tag,
		MPI_Comm comm, char * routName) {
  int rank;

  rank = $comm_place(comm.col);
  if (rank != root)
    CMPI_Send(sendbuf, count, datatype, root, tag, comm.col);
  else {
    int nprocs = $comm_size(comm.col);
    int size;

    size = count * sizeofDatatype(datatype);
    for (int i = 0; i<nprocs; i++) {
      if(i == root)
	memcpy(recvbuf, sendbuf, size);
      else{
	int colTag;
	$message in = $comm_dequeue(comm.col, i, MPI_ANY_TAG);

	colTag = $message_tag(in);
	$assert (colTag == tag , "Collective routine %s receives a "
		 "message with a mismatched tag\n", routName);
	/* the third argument "count" indicates the number of cells needs doing the
	   operation. */
	$bundle_unpack_apply(in.data, recvbuf, count, op);
	$assert (in.size <= size ,
		 "Message of size %d exceeds the specified size %d.", in.size, size);
      }
    }
  }
  return 0;
}

/* Gathering helper function that uses any specified message tag */
int CMPI_Gather(const void* sendbuf, int sendcount, MPI_Datatype sendtype, 
	       void* recvbuf, int recvcount, MPI_Datatype recvtype, 
		int root, int tag, MPI_Comm comm, char * routName){
  int rank, nprocs;
  _Bool rootInPlace = $false;
  MPI_Status status;

  rank = $comm_place(comm.col);
  nprocs = $comm_size(comm.col);
  if(sendbuf == MPI_IN_PLACE){// Sendbuf is ignored at root
    $assert (root == rank,
	     "Only root can replace 'sendbuf' with 'MPI_IN_PLACE'.");
    rootInPlace = $true;
  }
  else 
    CMPI_Send(sendbuf, sendcount, sendtype, root, tag, comm.col);
  // sendbuf cannot be ignored
  if(rank == root){
    int real_recvcount;
    int offset;

    // For root process, check if sendtype is equal to 
    // recvtype which is required by MPI standard.
    $assert (sendtype == recvtype,
    "%s asks for equality "
	     "between 'sendtype' and 'recvtype'.", routName);
    for(int i=0; i<nprocs; i++){
      // Since currently we don't support pointer addition 
      // on non-array type obejcts, we don't need 
      // to care about datatype extent.
      offset = i * recvcount; 
      if(!rootInPlace || i != root) {
	void * ptr = CMPI_PointerAdd(recvbuf, offset, recvtype);

	CMPI_Collective_recv(ptr, recvcount, recvtype, 
			     i, tag, comm.col, &status, routName);
	real_recvcount = status.size/sizeofDatatype(recvtype);
	$assert(real_recvcount == recvcount,
	"%s asks for equality between"
	  " the amount of data sent and the "
		"amount of data received.", routName);
      }
    }
  }
  return 0;
}

int CMPI_Gatherv(const void* sendbuf, int sendcount, MPI_Datatype sendtype,
		void* recvbuf, const int recvcounts[], const int displs[],
		 MPI_Datatype recvtype, int root, int tag, 
		 MPI_Comm comm, char * routName){
  int rank, nprocs;
  _Bool rootInPlace = $false;

  rank = $comm_place(comm.col);
  nprocs = $comm_size(comm.col);
  if(sendbuf == MPI_IN_PLACE){
    $assert(root == rank, "Only root can replace 'sendbuf' with 'MPI_IN_PLACE'.");
    rootInPlace = $true;
  }else{
    CMPI_Send(sendbuf, sendcount, sendtype, root, tag, comm.col);
  }
  //Root receive
  if(rank == root){
    int real_recvcount;
    MPI_Status status;

    $assert(sendtype == recvtype, "%s asks for equality "
	    "between 'sendtype' and 'recvtype'.", routName);
    for(int i=0; i<nprocs; i++){
      if(!rootInPlace || i != root){
	void * ptr = CMPI_PointerAdd(recvbuf, displs[i], recvtype);

	CMPI_Collective_recv(ptr, recvcounts[i], 
			     recvtype, i, tag, comm.col, &status, routName);
	real_recvcount = status.size/sizeofDatatype(recvtype);
	$assert(real_recvcount == recvcounts[i], "%s asks for equality between"
	  " the amount of data sent and the "
		"amount of data received.", routName);
      }
    }
  }
  return 0;
}

/* Scatter helper function that uses any specified message tag */
int CMPI_Scatter(const void* sendbuf, int sendcount, MPI_Datatype sendtype, 
		 void* recvbuf, int recvcount, MPI_Datatype recvtype, int root,
		 int tag, MPI_Comm comm, char * routName){
  int rank, nprocs;
  _Bool rootInPlace = $false;

  rank = $comm_place(comm.col);
  nprocs = $comm_size(comm.col);
  if(recvbuf == MPI_IN_PLACE){// Sendbuf is ignored at root
    $assert(root == rank, "Only root can replace 'recvbuf' with 'MPI_IN_PLACE'.");
    rootInPlace = $true;
  }
  if(rank == root){
    int offset;

    // For root process, check if sendtype is equal to  
    // recvtype which is required by MPI standard.
    $assert(sendtype == recvtype, "MPI_Scatter() asks for equality "
      "between 'sendtype' and 'recvtype'.");
    for(int i=0; i<nprocs; i++){
      offset = i * sendcount;
      if(!rootInPlace || i != root) {
	void * ptr = CMPI_PointerAdd(sendbuf, offset, sendtype);

	CMPI_Send(ptr, sendcount, sendtype, i, tag, comm.col);
      }
    }
  }
  if(!rootInPlace){//Already checked that (rootInPlace == true)==>(root==rank)
    int real_recvcount;
    MPI_Status status;
    
    CMPI_Collective_recv(recvbuf, recvcount, recvtype, 
			 root, tag, comm.col, &status, routName);
    real_recvcount = status.size/sizeofDatatype(recvtype);
    $assert(real_recvcount == recvcount,
    "%s asks for equality between"
      " the amount of data sent and the "
	    "amount of data received.", routName);
  }
  return 0;
}

/* Scatterv helper function that uses any specified message tag */
int CMPI_Scatterv(const void* sendbuf, const int sendcounts[], const
		 int displs[], MPI_Datatype sendtype, void* recvbuf,
		 int recvcount, MPI_Datatype recvtype, int root, int tag,
		  MPI_Comm comm, char * routName){
  int rank, nprocs;
  _Bool rootInPlace = $false;

  rank = $comm_place(comm.col);
  nprocs = $comm_size(comm.col);
  if(recvbuf == MPI_IN_PLACE){
    $assert(root == rank, "Only root can replace 'recvbuf' with 'MPI_IN_PLACE'.");
    rootInPlace = $true;
  }
  if(rank == root){
    //For process root, check sendtype and recvtype
    $assert(sendtype == recvtype, "%s asks for equality "
	    "between 'sendtype' and 'recvtype'.", routName);

    for(int i=0; i<nprocs; i++){
      if(!rootInPlace || i != root) {
	void * ptr = CMPI_PointerAdd(sendbuf, displs[i], sendtype);

	CMPI_Send(ptr, sendcounts[i], sendtype, i, 
		  tag, comm.col);
	//CMPI_Send(sendbuf + displs[i], sendcounts[i], sendtype, i, 
	// tag, comm.col);
      }
    }
  }
  if(!rootInPlace){
    MPI_Status status;
    int real_recvcount;

    CMPI_Collective_recv(recvbuf, recvcount, recvtype, 
			 root, tag, comm.col, &status, routName);
    real_recvcount = status.size/sizeofDatatype(recvtype);
    $assert(real_recvcount == recvcount, "Process rank:%d\n%s asks for equality between"
      " the amount of data sent (%d) and the "
	    "amount of data received (%d).", rank, routName, real_recvcount, recvcount);
  }
  return 0;
}

#endif

